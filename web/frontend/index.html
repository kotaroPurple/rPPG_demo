<!doctype html>
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>rPPG Web Dashboard</title>
    <style>
      body { font-family: -apple-system, BlinkMacSystemFont, sans-serif; margin: 16px; }
      .row { display: flex; gap: 16px; }
      .card { border: 1px solid #ddd; border-radius: 8px; padding: 12px; }
      .metrics span { margin-right: 16px; }
      #chart { width: 100%; height: 240px; }
    </style>
  </head>
  <body>
    <h2>rPPG Web Dashboard</h2>
    <div class="row">
      <div class="card" style="flex:2">
        <div class="metrics">
          <span id="bpm">BPM: --</span>
          <span id="rr">RR: --</span>
          <span id="snr">SNR: -- dB</span>
          <span id="conf">Conf: --</span>
          <span id="fs">fs: -- Hz</span>
        </div>
        <canvas id="chart"></canvas>
      </div>
      <div class="card" style="flex:1">
        <div>
          <label>Estimator</label>
          <select id="est">
            <option>FFT</option>
            <option>ACF</option>
            <option>Hilbert-IF</option>
            <option>Tracker(FFT)</option>
            <option>Tracker(ACF)</option>
            <option>Tracker(IF)</option>
          </select>
        </div>
        <div>
          <label>Algo</label>
          <select id="algo">
            <option>POS</option>
            <option>CHROM</option>
          </select>
        </div>
        <div>
          <label>Window (s)</label>
          <input id="win" type="number" min="1" max="15" step="1" value="8" />
        </div>
        <button id="apply">Apply</button>
        <hr />
        <div>
          <button id="startCap">Start Capture (getUserMedia)</button>
          <button id="stopCap">Stop Capture</button>
        </div>
        <video id="vid" autoplay playsinline style="width:100%;max-width:240px"></video>
        <canvas id="cam" width="160" height="120" style="display:none"></canvas>
      </div>
    </div>
    <script>
      const el = (id) => document.getElementById(id);
      const metrics = { xs: [], ys: [] };
      const maxPoints = 300;
      const ctx = el('chart').getContext('2d');
      const chart = new Chart(ctx, {
        type: 'line',
        data: { labels: [], datasets: [{ label: 'BPM', data: [], borderColor: '#2b6cb0' }] },
        options: { animation: false, responsive: true, scales: { y: { min: 40, max: 120 } } }
      });

      async function applyControl() {
        const body = {
          est: el('est').value,
          algo: el('algo').value,
          win_sec: parseFloat(el('win').value)
        };
        await fetch('/control', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(body) });
      }
      el('apply').onclick = applyControl;

      function updateMetrics(m) {
        el('bpm').textContent = `BPM: ${m.bpm?.toFixed?.(1) ?? '--'}`;
        el('rr').textContent = `RR: ${m.rr?.toFixed?.(1) ?? '--'}`;
        el('snr').textContent = `SNR: ${m.snr?.toFixed?.(1) ?? '--'} dB`;
        el('conf').textContent = `Conf: ${m.conf?.toFixed?.(2) ?? '--'}`;
        el('fs').textContent = `fs: ${m.fs?.toFixed?.(1) ?? '--'} Hz`;
        const t = m.t ?? Date.now()/1000;
        metrics.xs.push(t);
        metrics.ys.push(m.bpm ?? null);
        if (metrics.xs.length > maxPoints) { metrics.xs.shift(); metrics.ys.shift(); }
        const t0 = metrics.xs[metrics.xs.length - 1] - 90;
        const xs = metrics.xs.map(x => x - t0);
        chart.data.labels = xs;
        chart.data.datasets[0].data = metrics.ys;
        chart.update();
      }

      // getUserMedia capture and meanRGB ingestion
      let mediaStream = null;
      let ingestTimer = null;
      const meanQueue = [];
      let t0 = 0;
      let dt = 0.1; // 10 Hz sampling

      async function startCapture() {
        try {
          mediaStream = await navigator.mediaDevices.getUserMedia({ video: { width: 320, height: 240 }, audio: false });
          el('vid').srcObject = mediaStream;
          const ctxCam = el('cam').getContext('2d');
          t0 = Date.now() / 1000;
          if (ingestTimer) clearInterval(ingestTimer);
          ingestTimer = setInterval(() => {
            if (!mediaStream) return;
            ctxCam.drawImage(el('vid'), 0, 0, el('cam').width, el('cam').height);
            const frame = ctxCam.getImageData(0, 0, el('cam').width, el('cam').height).data;
            let r=0,g=0,b=0, n=0;
            // Sample every 4th pixel for speed
            for (let i=0; i<frame.length; i+=16) { r+=frame[i]; g+=frame[i+1]; b+=frame[i+2]; n++; }
            meanQueue.push([r/n, g/n, b/n]);
            if (meanQueue.length >= 10) { // send ~1s batch
              fetch('/ingest', {
                method: 'POST', headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ t0, dt, mean_rgb: meanQueue.splice(0, meanQueue.length) })
              }).catch(()=>{});
              t0 += 10 * dt;
            }
          }, dt*1000);
        } catch (e) {
          console.error('getUserMedia failed', e);
        }
      }

      function stopCapture() {
        if (ingestTimer) { clearInterval(ingestTimer); ingestTimer = null; }
        if (mediaStream) { mediaStream.getTracks().forEach(t => t.stop()); mediaStream = null; }
      }

      async function bootstrap() {
        try {
          const res = await fetch('/metrics');
          updateMetrics(await res.json());
        } catch {}
        try {
          const ws = new WebSocket((location.protocol === 'https:' ? 'wss://' : 'ws://') + location.host + '/ws');
          ws.onmessage = (e) => { try { updateMetrics(JSON.parse(e.data)); } catch {} };
          ws.onclose = () => setTimeout(bootstrap, 2000);
        } catch {
          setTimeout(bootstrap, 2000);
        }
      }
      // load Chart.js dynamically (CDN)
      const s = document.createElement('script');
      s.src = 'https://cdn.jsdelivr.net/npm/chart.js';
      s.onload = bootstrap;
      document.head.appendChild(s);
      el('startCap').onclick = startCapture;
      el('stopCap').onclick = stopCapture;
    </script>
  </body>
  </html>
